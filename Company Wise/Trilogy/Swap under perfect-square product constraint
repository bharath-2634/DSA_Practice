Question:

 You have an array of n natural numbers. You can swap the numbers at ith and (i+1)th 
positions if their product is a square of a natural number. Can you sort the array in non 
decreasing manner using this operation multiple times (possibly 0) 
Answer: Yes/No 
Sample Cases: 
[4, 1, 6, 18, 8] -> Yes 
[9, 4, 1] -> No

Solution:

import java.util.*;

/*
This is my brute force naive approach

class Main {

    public static boolean isSorted(int[] nums) {
        for(int i=1;i<nums.length;i++) {
            if(nums[i-1] > nums[i]) return false;
        }

        return true;
    }

    public static boolean isPerfectSquare(int n) {
        int pr = (int)Math.sqrt(n);
        return pr*pr==n;
    }

    public static boolean isSortable(int[] nums) {
        

        while(!isSorted(nums)) {
            boolean isSwapped = false;
            for(int i=1;i<nums.length;i++) {
                int pr = nums[i-1]*nums[i];
                if(isPerfectSquare(pr) && nums[i-1] > nums[i]) {
                    int temp = nums[i-1];
                    nums[i-1]= nums[i];
                    nums[i] = temp;
                    isSwapped = true;
                }
            }
            if(!isSwapped) return false;
        }

        return true;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] nums = new int[n];

        for(int i=0;i<n;i++) {
            nums[i] = sc.nextInt();
        }

        System.out.println(isSortable(nums));
    }
}

*/

/*
class Main {

    public static int getPrimeCount(int n) {

        int res=1;

        for(int p=2;p*p<=n;p++) {
            int count=0;
            while(n%p==0) {
                count++;
                n/=p;
            }

            if(count%2==1) {
                res = res*p;
            }
        }

        if(n>1) {
            res = res*n;
        }

        return res;
    }

    public static boolean isSortable(int[] nums) {

        int[] prime_idx = new int[nums.length];
        Map<Integer,List<Integer>> cMap = new LinkedHashMap<>();

        for(int i=0;i<nums.length;i++) {
            int prime_count = getPrimeCount(nums[i]);
            prime_idx[i] = prime_count;
            cMap.computeIfAbsent(prime_count,k->new ArrayList<>()).add(nums[i]);
        }

        for(List<Integer> val : cMap.values()) {
            Collections.sort(val);
        }

        int[] res = new int[nums.length];
        Map<Integer,Integer> indexMap = new HashMap<>();

        for(int i=0;i<nums.length;i++) {
            int key = prime_idx[i];
            int idx = indexMap.getOrDefault(key,0);
            res[i] = cMap.get(key).get(idx);
            indexMap.put(key,idx+1);
        }

        for(int i=1;i<nums.length;i++) {
            if(res[i-1]>res[i]) return false;
        }

        return true;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] nums = new int[n];

        for(int i=0;i<n;i++) {
            nums[i] = sc.nextInt();
        }

        System.out.println(isSortable(nums));
    }
}

*/

class DSU {
    List<Integer> parent;
    List<Integer> size;

    public DSU(int n) {
        parent = new ArrayList<>();
        size = new ArrayList<>();

        for(int i=0;i<n;i++) {
            parent.add(i);
            size.add(1);
        }
    }

    public int findUltimateParent(int n) {
        if(parent.get(n)==n) return n;

        int ulp = findUltimateParent(parent.get(n));
        parent.set(n,ulp);
        return ulp;
    }

    public void union(int x,int y) {
        int ulp_x = findUltimateParent(x);
        int ulp_y = findUltimateParent(y);

        if(ulp_x==ulp_y) return;

        if(size.get(ulp_x) > size.get(ulp_y)) {
            parent.set(ulp_y,ulp_x);
            size.set(ulp_x,size.get(ulp_x)+size.get(ulp_y));
        }else if(size.get(ulp_x) < size.get(ulp_y)) {
            parent.set(ulp_x,ulp_y);
            size.set(ulp_y,size.get(ulp_x)+size.get(ulp_y));
        }else {
            parent.set(ulp_x,ulp_y);
            size.set(ulp_y,size.get(ulp_x)+size.get(ulp_y));
        }   
    }
}

class Main {

    public static int getPrimeCount(int n) {

        int result=1;

        for(int p=2;p*p<=n;p++) {
            int count=0;
            while(n%p==0) {
                count++;
                n/=p;
            }

            if(count%2==1) {
                result*=p;
            }
        }

        if(n>1) {
            result*=n;
        }

        return result;
    }

    public static boolean isSortable(int[] nums) {
        DSU dsu = new DSU(nums.length);
        int[] prime_idx = new int[nums.length];
        for(int i=0;i<nums.length;i++) {
            int idx = getPrimeCount(nums[i]);
            prime_idx[i] = idx;
        }

        for(int i=1;i<nums.length;i++) {
            if(prime_idx[i-1]==prime_idx[i]) {
                dsu.union(i,i-1);
            }
        }

        Map<Integer,List<Integer>> indexMap = new HashMap<>();

        for(int i=0;i<nums.length;i++) {
            int root = dsu.findUltimateParent(i);
            indexMap.computeIfAbsent(root,k->new ArrayList<>()).add(i);
        }

        int[] res = nums.clone();

        for(List<Integer> indices : indexMap.values()) {
            List<Integer> values = new ArrayList<>();
            for(int i : indices) {
                values.add(nums[i]);
            }

            Collections.sort(values);
            Collections.sort(indices);

            for(int i=0;i<values.size();i++) {
                res[indices.get(i)] = values.get(i);
            }
        }

        for(int i=1;i<res.length;i++) {
            if(res[i-1] > res[i]) return false;
        }

        return true;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] nums = new int[n];

        for(int i=0;i<n;i++) {
            nums[i] = sc.nextInt();
        }

        System.out.println(isSortable(nums));
    }
}
