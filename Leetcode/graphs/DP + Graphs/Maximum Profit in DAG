Question: 

Problem: Maximum Profit in DAG

You are given:

An integer n representing the number of projects labeled from 1 to n.

An array profit[] where profit[i] is the profit earned from completing project i.

A list of prerequisite relations relations, where each relation [u, v] means:

Project u must be completed before project v.

You may start with any project that has no prerequisites.

If you choose to complete a project, you must also complete all of its prerequisite projects.

üéØ Objective

Return the maximum total profit obtainable from any valid project sequence.

A valid sequence must respect prerequisite constraints.

You may end at any project ‚Äî you do not need to complete all projects.

üß† Interpretation

The projects form a Directed Acyclic Graph (DAG).

Each project has a profit (node weight).

You are looking for:

The maximum profit path in the DAG.

üìò Example 1
Input
n = 5
profit = [5, 10, 3, 8, 7]
relations = [[1,3], [2,3], [3,4], [2,5]]

Explanation

Valid chains:

1 ‚Üí 3 ‚Üí 4 = 5 + 3 + 8 = 16

2 ‚Üí 3 ‚Üí 4 = 10 + 3 + 8 = 21

2 ‚Üí 5 = 10 + 7 = 17

Maximum = 21

Output
21

üìò Example 2
Input
n = 4
profit = [4, 2, 7, 1]
relations = [[1,2], [1,3], [3,4]]

Explanation

Chains:

1 ‚Üí 2 = 4 + 2 = 6

1 ‚Üí 3 ‚Üí 4 = 4 + 7 + 1 = 12

Maximum = 12

Output
12

üìò Example 3 (Multiple Independent Starts)
Input
n = 3
profit = [6, 9, 5]
relations = []

Explanation

No dependencies.

You can pick any single project.

Maximum profit = 9

Output
9

üìò Example 4 (Negative Profit Case)
Input
n = 3
profit = [5, -2, 4]
relations = [[1,2], [2,3]]

Explanation

Chain:
1 ‚Üí 2 ‚Üí 3 = 5 - 2 + 4 = 7

But stopping at:
1 alone = 5

Maximum = 7

Output
7

üîé Constraints (Typical)

1 ‚â§ n ‚â§ 10‚Åµ

0 ‚â§ relations.length ‚â§ 10‚Åµ

Graph is guaranteed to be a DAG

Profit values may be positive or negative

Solution:

import java.util.*;

/*
class Main {
    public static int dfs(int node,Map<Integer,List<Integer>> adjList,int[] profit,int[] dp) {
        
        if(!adjList.containsKey(node) || adjList.get(node).size()==0) {
            return profit[node];
        }

        if(dp[node]!=-1) return dp[node];

        int max_profit = 0;
        for(int adjNode : adjList.getOrDefault(node,new ArrayList<>())) {
            max_profit = Math.max(max_profit,dfs(adjNode,adjList,profit,dp));
        }

        return dp[node] = max_profit+profit[node];
    }
    
    public static void generateAdjList(int[][] edges,Map<Integer,List<Integer>> adjList) {

        for(int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];

            if(!adjList.containsKey(u)) {
                adjList.put(u,new ArrayList<>());
            }

            adjList.get(u).add(v);
        }
    }

    public static int maxProfit(int[][] edges,int[] profit) {
        Map<Integer,List<Integer>> adjList = new HashMap<>();
        generateAdjList(edges,adjList);
        int[] dp = new int[edges.length];
        Arrays.fill(dp,-1);
        
        int max_profit= Integer.MIN_VALUE;

        for(int node : adjList.keySet()) {
            max_profit = Math.max(max_profit,dfs(node,adjList,profit,dp));
        }

        return max_profit;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] edges = new int[n-1][2];

        for(int i=0;i<n-1;i++) {
            edges[i][0] = sc.nextInt();
            edges[i][1] = sc.nextInt();
        } 

        int[] profit = new int[n];
        for(int i=0;i<n;i++) profit[i] = sc.nextInt();

        System.out.println(maxProfit(edges,profit));
    }
}

*/

class Main {

    public static void generateAdjList(int[][] edges,Map<Integer,List<Integer>> adjList,int[] inDegree) {

        for(int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];

            inDegree[v]++;

            if(!adjList.containsKey(u)) {
                adjList.put(u,new ArrayList<>());
            }

            adjList.get(u).add(v);
        }
    }

    public static int maxProfit(int[][] edges,int[] profit) {
        Map<Integer,List<Integer>> adjList = new HashMap<>();
        int[] inDegree = new int[profit.length];
        generateAdjList(edges,adjList,inDegree);
        int[] dp = new int[profit.length];
        Arrays.fill(dp,-1);

        Queue<Integer> q = new LinkedList<>();
        for(int i=0;i<profit.length;i++) {
            if(inDegree[i]==0) {
                dp[i] = profit[i];
                q.offer(i);
            }
        }

        int max_profit = Integer.MIN_VALUE;

        while(!q.isEmpty()) {
            int node = q.poll();
            max_profit = Math.max(max_profit,dp[node]);

            for(int adjNode : adjList.getOrDefault(node,new ArrayList<>())) {
                inDegree[adjNode]--;
                dp[adjNode] = Math.max(dp[adjNode],dp[node]+profit[adjNode]);
                if(inDegree[adjNode]==0) {
                    q.offer(adjNode);
                }
            }
        }

        return max_profit;
        
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] edges = new int[n-1][2];

        for(int i=0;i<n-1;i++) {
            edges[i][0] = sc.nextInt();
            edges[i][1] = sc.nextInt();
        } 

        int[] profit = new int[n];
        for(int i=0;i<n;i++) profit[i] = sc.nextInt();

        System.out.println(maxProfit(edges,profit));
    }
}
