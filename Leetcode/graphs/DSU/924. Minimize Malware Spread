Question: https://leetcode.com/problems/minimize-malware-spread/

Solution:

class DSU {
    List<Integer> parent;
    List<Integer> size;

    public DSU(int n) {
        parent = new ArrayList<>();
        size = new ArrayList<>();

        for(int i=0;i<n;i++) {
            parent.add(i);
            size.add(1);
        }
    }

    public int findUltimateParent(int n) {
        if(parent.get(n)==n) return n;

        int ulp = findUltimateParent(parent.get(n));
        parent.set(n,ulp);

        return ulp;
    }

    public void unionBySize(int x,int y) {
        int ulp_x = findUltimateParent(x);
        int ulp_y = findUltimateParent(y);

        if(ulp_x==ulp_y) return;

        if(size.get(ulp_x)<size.get(ulp_y)) {
            size.set(ulp_y,size.get(ulp_x)+size.get(ulp_y));
            parent.set(ulp_x,ulp_y);
        }else if(size.get(ulp_x) > size.get(ulp_y)) {
            size.set(ulp_x,size.get(ulp_x)+size.get(ulp_y));
            parent.set(ulp_y,ulp_x);
        }else {
            size.set(ulp_x,size.get(ulp_x)+size.get(ulp_y));
            parent.set(ulp_y,ulp_x);
        }
    }
}

class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        DSU dsu = new DSU(graph.length);

        for(int node=0;node<graph.length;node++) {
            for(int co=0;co<graph[node].length;co++) {
                if(node!=co && graph[node][co]==1) {
                    dsu.unionBySize(node,co);
                }
            }
        }

        Map<Integer,Integer> components = new HashMap<>();
        for(int node=0;node<graph.length;node++) {
            int ulp = dsu.findUltimateParent(node);
            components.put(ulp,components.getOrDefault(ulp,0)+1);
        }

        Map<Integer,Integer> infectedNodes = new HashMap<>();
        for(int node : initial) {
            int ulp = dsu.findUltimateParent(node);
            infectedNodes.put(ulp,infectedNodes.getOrDefault(ulp,0)+1);
        }

        int maxSaved = 0,minNode=Integer.MAX_VALUE;
        for(int node : initial) {
            int ulp = dsu.findUltimateParent(node);
            if(infectedNodes.get(ulp)==1) {
                int component_size = components.get(ulp);
                if(component_size > maxSaved || (component_size==maxSaved && node<minNode)) {
                    minNode = node;
                    maxSaved = component_size;
                }
            }
        }

        if(minNode==Integer.MAX_VALUE) {
            for(int node : initial) {
                minNode = Math.min(minNode,node);
            }
        }

        return minNode;
    }
}
