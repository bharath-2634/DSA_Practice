Question: https://www.geeksforgeeks.org/problems/eventual-safe-states/1

Solution:
/*
This is my dfs approach
class Solution {
    
    public void generateAdjList(int[][] edges,HashMap<Integer,List<Integer>> adjList) {
        for(int[] edge: edges) {
            int u = edge[0];
            int v = edge[1];
            
            if(!adjList.containsKey(u)) {
                adjList.put(u,new ArrayList<>());
            }
            
            adjList.get(u).add(v);
        }
    }
    
    public boolean dfs(int node,HashMap<Integer,List<Integer>> adjList,boolean[] visited,boolean[] pathVisited,boolean[] safeNode) {
        visited[node] = true;
        pathVisited[node] = true;
        
        for(int adjNode : adjList.getOrDefault(node,new ArrayList<>())) {
            if(!visited[adjNode]) {
                if(dfs(adjNode,adjList,visited,pathVisited,safeNode)) return true;
            }else if(pathVisited[adjNode]) return true;
        }
        
        pathVisited[node] = false;
        safeNode[node] = true;
        return false;
    }
    
    public ArrayList<Integer> safeNodes(int V, int[][] edges) {
       HashMap<Integer,List<Integer>> adjList = new HashMap<>();
       generateAdjList(edges,adjList);
       
       boolean[] visited = new boolean[V];
       boolean[] pathVisited = new boolean[V];
       boolean[] safeNode= new boolean[V];
       
       for(int node=0;node<V;node++) {
           if(!visited[node]) {
               dfs(node,adjList,visited,pathVisited,safeNode);
           }
       }
       
       ArrayList<Integer> ls = new ArrayList<>();
       for(int i=0;i<V;i++) {
           if(safeNode[i]) ls.add(i);
       }
       
      Collections.sort(ls);
       
       return ls;
       
    }
}
*/

class Solution {
    public void generateAdjList(int[][] edges,HashMap<Integer,List<Integer>> adjList) {
        for(int[] edge: edges) {
            int u = edge[0];
            int v = edge[1];
            
            if(!adjList.containsKey(v)) {
                adjList.put(v,new ArrayList<>());
            }
            adjList.get(v).add(u);
        }
    }
    
    public ArrayList<Integer> safeNodes(int V, int[][] edges) {
        HashMap<Integer,List<Integer>> adjList = new HashMap<>();
        generateAdjList(edges,adjList);
        
        int[] outDegree = new int[V];
        Queue<Integer> q = new LinkedList<>();
        
        for(int node : adjList.keySet()) {
            for(int adjNode : adjList.getOrDefault(node,new ArrayList<>())) {
                outDegree[adjNode]++;        
            }
        }
        
        for(int i=0;i<V;i++) {
            if(outDegree[i]==0) {
                q.offer(i);
            }
        }
        
        ArrayList<Integer> ds = new ArrayList<>();
        int count=0;
        while(!q.isEmpty()) {
            int node = q.poll();
            ds.add(node);
            count++;
            for(int adjNode : adjList.getOrDefault(node,new ArrayList<>())) {
                outDegree[adjNode]--;
                if(outDegree[adjNode]==0) {
                    q.offer(adjNode);
                }
            }
        }
        
        Collections.sort(ds);
        return ds;
    }
}



