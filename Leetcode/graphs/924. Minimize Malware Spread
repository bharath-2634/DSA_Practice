Question: https://leetcode.com/problems/minimize-malware-spread/

Solution:

/*
class DSU {
    List<Integer> parent;
    List<Integer> size;

    public DSU(int n) {
        parent = new ArrayList<>();
        size = new ArrayList<>();

        for(int i=0;i<n;i++) {
            parent.add(i);
            size.add(1);
        }
    }

    public int findUltimateParent(int n) {
        if(parent.get(n)==n) return n;

        int ulp = findUltimateParent(parent.get(n));
        parent.set(n,ulp);

        return ulp;
    }

    public void unionBySize(int x,int y) {
        int ulp_x = findUltimateParent(x);
        int ulp_y = findUltimateParent(y);

        if(ulp_x==ulp_y) return;

        if(size.get(ulp_x)<size.get(ulp_y)) {
            size.set(ulp_y,size.get(ulp_x)+size.get(ulp_y));
            parent.set(ulp_x,ulp_y);
        }else if(size.get(ulp_x) > size.get(ulp_y)) {
            size.set(ulp_x,size.get(ulp_x)+size.get(ulp_y));
            parent.set(ulp_y,ulp_x);
        }else {
            size.set(ulp_x,size.get(ulp_x)+size.get(ulp_y));
            parent.set(ulp_y,ulp_x);
        }
    }
}

class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        DSU dsu = new DSU(graph.length);

        for(int node=0;node<graph.length;node++) {
            for(int co=0;co<graph[node].length;co++) {
                if(node!=co && graph[node][co]==1) {
                    dsu.unionBySize(node,co);
                }
            }
        }

        Map<Integer,Integer> components = new HashMap<>();
        for(int node=0;node<graph.length;node++) {
            int ulp = dsu.findUltimateParent(node);
            components.put(ulp,components.getOrDefault(ulp,0)+1);
        }

        Map<Integer,Integer> infectedNodes = new HashMap<>();
        for(int node : initial) {
            int ulp = dsu.findUltimateParent(node);
            infectedNodes.put(ulp,infectedNodes.getOrDefault(ulp,0)+1);
        }

        int maxSaved = 0,minNode=Integer.MAX_VALUE;
        for(int node : initial) {
            int ulp = dsu.findUltimateParent(node);
            if(infectedNodes.get(ulp)==1) {
                int component_size = components.get(ulp);
                if(component_size > maxSaved || (component_size==maxSaved && node<minNode)) {
                    minNode = node;
                    maxSaved = component_size;
                }
            }
        }

        if(minNode==Integer.MAX_VALUE) {
            for(int node : initial) {
                minNode = Math.min(minNode,node);
            }
        }

        return minNode;
    }
}
*/

class Solution {

    public void dfs(int node,int[] color,int color_count,int[][] graph) {
        color[node] = color_count;

        for(int adjNode=0;adjNode<graph.length;adjNode++) {
            if(color[adjNode]==-1 && graph[node][adjNode]==1) {
                dfs(adjNode,color,color_count,graph);
            }
        }
    }

    public int minMalwareSpread(int[][] graph, int[] initial) {
        
        int[] color = new int[graph.length];
        Arrays.fill(color,-1);
        int color_count=-1;
        for(int node=0;node<graph.length;node++) {
            if(color[node]==-1) {
                color_count++;
                dfs(node,color,color_count,graph);
            }
        }

        int[] size = new int[color_count+1];
        for(int i=0;i<=color_count;i++) {
            for(int j=0;j<color.length;j++) {
                if(color[j]==i) {
                    size[i]++;
                }
            }
        }

        // Count infected nodes per component
        int[] infectedCount = new int[color_count + 1];
        for(int node : initial) {
            infectedCount[color[node]]++;
        }

        Arrays.sort(initial); // important for tie-breaking

        int maxSaved = 0;
        int answer = initial[0];

        for(int node : initial) {
            int comp = color[node];

            // Only useful if this component has exactly 1 infected node
            if(infectedCount[comp] == 1) {
                if(size[comp] > maxSaved) {
                    maxSaved = size[comp];
                    answer = node;
                }
            }
        }

        // If no node saved anything, smallest index is already answer
        return answer;
    }
}
