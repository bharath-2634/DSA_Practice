Question : https://leetcode.com/problems/merge-k-sorted-lists/description/

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    /*
    This is my naive solution
    public ListNode mergeKLists(ListNode[] lists) {
        List<Integer> data = new ArrayList<>();
        for(ListNode list : lists) {
            while(list!=null) {
                data.add(list.val);
                list = list.next;
            }
        }

        Collections.sort(data);
        ListNode res = new ListNode(-1);
        ListNode tail = res;

        for(int d : data) {
            ListNode node = new ListNode(d);
            tail.next = node;
            tail = tail.next;
        }

        return res.next;
    }
    */

    /*
    This is my Priority Queue Approach
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> pq = new PriorityQueue<>((a,b)-> Integer.compare(a.val,b.val));

        for(ListNode list : lists) {
            if(list!=null) pq.add(list);
        }
        
        ListNode res = new ListNode(-1);
        ListNode tail = res;

        while(!pq.isEmpty()) {
            ListNode node = pq.poll();
            tail.next = node;
            tail = tail.next;
            if(node!=null && node.next!=null) pq.offer(node.next);
        }

        return res.next;
    }
    */
    /* My Divide and Conquer Approach */

    public ListNode mergeLists(ListNode l1,ListNode l2) {
        if(l1==null && l2==null) return null;

        if(l1==null) return l2;

        if(l2==null) return l1;

        if(l1.val<=l2.val) {
            l1.next = mergeLists(l1.next,l2);
            return l1;
        }else {
            l2.next = mergeLists(l1,l2.next);
            return l2;
        }

    }

    public ListNode getMergeLists(ListNode[] lists,int start,int end) {
        
        if(end<start) return null;
        //base case
        if(end==start) return lists[end];

        //split
        int mid = start+(end-start)/2;
        ListNode left_list = getMergeLists(lists,start,mid);
        ListNode right_list = getMergeLists(lists,mid+1,end);
        //merge
        return mergeLists(left_list,right_list);
    }

    public ListNode mergeKLists(ListNode[] lists) {
        
        return getMergeLists(lists,0,lists.length-1);
    }
}
